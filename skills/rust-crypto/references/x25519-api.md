# X25519-dalek API Reference

## Table of Contents

- [Overview](#overview)
- [Structs](#structs)
- [Constants](#constants)
- [Functions](#functions)
- [Feature Flags](#feature-flags)
- [Usage Patterns](#usage-patterns)
- [Dependencies](#dependencies)

## Overview

Pure Rust implementation of X25519 Diffie-Hellman key exchange (RFC 7748) using the dalek cryptography library. Provides ephemeral, reusable, and static secret key types for key agreement.

## Structs

### EphemeralSecret

Short-lived secret key for single-use Diffie-Hellman. Cannot be serialized (prevents accidental reuse).

```rust
use x25519_dalek::{EphemeralSecret, PublicKey};
use rand::rngs::OsRng;

let secret = EphemeralSecret::random_from_rng(OsRng);
let public = PublicKey::from(&secret);
```

Methods:
- `random_from_rng(rng)` -- generate from CSPRNG
- `diffie_hellman(peer_public)` -- compute shared secret (consumes self)

### StaticSecret (feature: `static_secrets`)

Long-lived reusable secret key. Can be serialized.

```rust
use x25519_dalek::StaticSecret;
use rand::rngs::OsRng;

let secret = StaticSecret::random_from_rng(OsRng);
let public = PublicKey::from(&secret);

// Can be used multiple times
let shared1 = secret.diffie_hellman(&peer1_public);
let shared2 = secret.diffie_hellman(&peer2_public);
```

Methods:
- `random_from_rng(rng)` -- generate from CSPRNG
- `diffie_hellman(peer_public)` -- compute shared secret (borrows self)
- `to_bytes()` -- serialize to 32 bytes
- `from(bytes: [u8; 32])` -- deserialize from 32 bytes

### ReusableSecret (feature: `reusable_secrets`)

Reusable secret key without serialization support. Middle ground between Ephemeral and Static.

### PublicKey

X25519 public key. 32 bytes.

```rust
let public = PublicKey::from(&secret);
let bytes = public.to_bytes();
let public = PublicKey::from(bytes);
```

### SharedSecret

Result of Diffie-Hellman key exchange. 32 bytes.

```rust
let shared = secret.diffie_hellman(&peer_public);
let bytes: &[u8; 32] = shared.as_bytes();
```

**Warning**: `SharedSecret` is a raw DH output. Always derive an actual encryption key from it using HKDF or similar KDF before using it for encryption.

## Constants

- **X25519_BASEPOINT_BYTES** -- The X25519 basepoint `[u8; 32]` for low-level operations

## Functions

### x25519

Bare byte-oriented X25519 function (RFC 7748):

```rust
use x25519_dalek::x25519;

let shared = x25519(secret_bytes, public_bytes);
```

## Feature Flags

| Feature | Description |
|---------|-------------|
| `serde` | Serialization for StaticSecret and PublicKey |
| `zeroize` | Zero secret material on drop |
| `reusable_secrets` | Enable `ReusableSecret` type |
| `static_secrets` | Enable `StaticSecret` type |

## Usage Patterns

### Ephemeral key exchange (most common)

```rust
use x25519_dalek::{EphemeralSecret, PublicKey};
use rand::rngs::OsRng;

// Alice generates ephemeral keypair
let alice_secret = EphemeralSecret::random_from_rng(OsRng);
let alice_public = PublicKey::from(&alice_secret);

// Bob generates ephemeral keypair
let bob_secret = EphemeralSecret::random_from_rng(OsRng);
let bob_public = PublicKey::from(&bob_secret);

// Exchange public keys, then compute shared secret
let alice_shared = alice_secret.diffie_hellman(&bob_public);
let bob_shared = bob_secret.diffie_hellman(&alice_public);
assert_eq!(alice_shared.as_bytes(), bob_shared.as_bytes());
```

### Derive encryption key from DH shared secret

```rust
use x25519_dalek::{EphemeralSecret, PublicKey};
use hkdf::Hkdf;
use sha2::Sha256;
use rand::rngs::OsRng;

let secret = EphemeralSecret::random_from_rng(OsRng);
let public = PublicKey::from(&secret);

// After exchanging public keys...
let shared = secret.diffie_hellman(&peer_public);

// ALWAYS derive a proper key -- never use raw shared secret directly
let hk = Hkdf::<Sha256>::new(None, shared.as_bytes());
let mut enc_key = [0u8; 32];
hk.expand(b"encryption-key-v1", &mut enc_key).unwrap();
```

### Static key for server identity (feature: `static_secrets`)

```rust
use x25519_dalek::{StaticSecret, PublicKey};
use rand::rngs::OsRng;

// Generate once, store securely
let server_secret = StaticSecret::random_from_rng(OsRng);
let server_public = PublicKey::from(&server_secret);

// Serialize for storage
let secret_bytes = server_secret.to_bytes();
let public_bytes = server_public.to_bytes();

// Restore
let server_secret = StaticSecret::from(secret_bytes);
```

## Dependencies

```toml
[dependencies]
x25519-dalek = { version = "2", features = ["static_secrets"] }
rand = "0.8"
```

For minimal ephemeral-only:

```toml
[dependencies]
x25519-dalek = "2"
rand = "0.8"
```

- License: BSD-3-Clause
