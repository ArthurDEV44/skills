# Async Traits Internals: Future, Pin, Unpin, Stream

## The Future Trait

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

- `Output`: the resolved value type
- `poll()`: called by the runtime to check if the future is ready
- Returns `Poll::Ready(T)` or `Poll::Pending`
- On `Pending`, the future **must** arrange for `cx.waker().wake()` to be called when progress is possible
- Never poll a future again after it returns `Ready` (fused futures aside)

### Poll enum

```rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

### How await compiles

```rust
// This:
let value = my_future.await;

// Becomes roughly:
loop {
    match Pin::new(&mut my_future).poll(cx) {
        Poll::Ready(value) => break value,
        Poll::Pending => yield, // return control to the executor
    }
}
```

The runtime handles the scheduling: it suspends the current task, and the waker (stored in `Context`) notifies the executor when the future should be polled again.

### Async state machines

Each `async fn` compiles into a state machine enum with one variant per await point:

```rust
// Conceptual -- compiler generates this
enum FetchDataFuture {
    Start { url: String },
    AfterGet { response: Response },
    Done,
}

impl Future for FetchDataFuture {
    type Output = Result<String, Error>;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // Compiler-generated state transitions between variants
        // Each .await becomes a state transition boundary
        todo!()
    }
}
```

The state machine captures all local variables that live across `.await` points. Variables used only before the first `.await` or only after the last `.await` are NOT stored in the state machine.

## Pin and Unpin

### The problem

Async state machines can contain **self-referential data** (a field borrowing another field). If the struct moves in memory, these internal references become dangling:

```rust
async fn example() {
    let data = vec![1, 2, 3];
    let reference = &data; // self-referential: reference points to data
    tokio::time::sleep(Duration::from_secs(1)).await;
    // After this await, both `data` and `reference` are stored in the state machine.
    // If the state machine moves, `reference` would dangle.
    println!("{reference:?}");
}
```

### Pin prevents movement

`Pin<P>` wraps a pointer type `P` and guarantees the pointed-to value won't be moved:

```rust
use std::pin::Pin;

// Pin on the heap (common for spawning)
let pinned: Pin<Box<dyn Future<Output = ()>>> = Box::pin(some_future);

// Pin on the stack (common for join_all)
use std::pin::pin;
let pinned = pin!(some_future);
```

- `Pin<Box<T>>` pins the `T` on the heap, not the `Box`
- `Pin<&mut T>` pins the `T` at its current stack location
- The pointer itself can move; the pointed-to data stays put

### Unpin marker trait

- Most types are `Unpin` (safe to move even when pinned): `String`, `Vec`, `i32`, references, etc.
- Async state machines generated by the compiler are `!Unpin` (not safe to move) due to potential self-references
- If `T: Unpin`, `Pin<&mut T>` behaves like `&mut T` (pin has no effect)

### Practical usage

**Stack pinning with `pin!` macro (known at compile time):**

```rust
use std::pin::pin;
use std::future::Future;

let fut_a = pin!(async { do_a().await });
let fut_b = pin!(async { do_b().await });
let fut_c = pin!(async { do_c().await });

let futures: Vec<Pin<&mut dyn Future<Output = ()>>> =
    vec![fut_a, fut_b, fut_c];

futures::future::join_all(futures).await;
```

**Heap pinning with `Box::pin` (works across scopes, required for spawning):**

```rust
let futures: Vec<Pin<Box<dyn Future<Output = ()> + Send>>> = vec![
    Box::pin(async { do_a().await }),
    Box::pin(async { do_b().await }),
];
futures::future::join_all(futures).await;
```

### Common Pin errors and fixes

```
error[E0277]: `dyn Future<Output = ()>` cannot be unpinned
```
**Fix:** Wrap futures with `pin!()` (stack) or `Box::pin()` (heap).

```
error[E0277]: ... cannot be sent between threads safely
```
**Fix:** Ensure the future is `Send`. See [advanced-patterns.md](advanced-patterns.md) for Send bounds.

## The Stream Trait

```rust
use std::pin::Pin;
use std::task::{Context, Poll};

trait Stream {
    type Item;
    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Self::Item>>;
}
```

Combines Iterator (sequence of items) with Future (readiness over time):

| Trait | Yields | Readiness |
|-------|--------|-----------|
| Iterator | `Option<Item>` | Immediate |
| Future | `Output` | Async (Poll) |
| Stream | `Poll<Option<Item>>` | Async sequence |

### StreamExt

Extension trait providing convenience methods:

```rust
trait StreamExt: Stream {
    async fn next(&mut self) -> Option<Self::Item>
    where Self: Unpin;

    fn map<T, F>(self, f: F) -> Map<Self, F>
    where F: FnMut(Self::Item) -> T;

    fn filter<F>(self, f: F) -> Filter<Self, F>
    where F: FnMut(&Self::Item) -> bool;

    fn take(self, n: usize) -> Take<Self>;
    fn skip(self, n: usize) -> Skip<Self>;

    async fn collect<B: Default + Extend<Self::Item>>(self) -> B
    where Self: Unpin;

    // ... fold, for_each, chain, zip, etc.
}
```

- Auto-implemented for all `Stream` types
- Provided by `tokio-stream` (`tokio_stream::StreamExt`) or `futures` (`futures::StreamExt`)
- Not yet in std

### Creating streams

```rust
use tokio_stream::{self as stream, StreamExt};

// From iterator
let s = stream::iter(vec![1, 2, 3]);

// From async channel receiver
let (tx, rx) = tokio::sync::mpsc::channel(32);
let s = tokio_stream::wrappers::ReceiverStream::new(rx);

// From a repeating interval
let s = tokio_stream::wrappers::IntervalStream::new(
    tokio::time::interval(Duration::from_secs(1))
);

// Custom with async_stream crate
use async_stream::stream;
let s = stream! {
    for i in 0..3 {
        tokio::time::sleep(Duration::from_millis(100)).await;
        yield i;
    }
};
```

## Sources

- [Traits for async](https://doc.rust-lang.org/book/ch17-05-traits-for-async.html)
- [Streams](https://doc.rust-lang.org/book/ch17-04-streams.html)
- [Async Book: The Future Trait](https://rust-lang.github.io/async-book/02_execution/02_future.html)
- [std::pin module](https://doc.rust-lang.org/std/pin/index.html)
